
=head1 History

It all comes from L<DBIx::SearchBuilder> and RT which has quite flexible
query builder. Queries are implemented as strings close to SQL, but with
special syntax for columns. For example it can be 'Requester.Login =
"ruz"'. Such thing works quite good, but only for tickets and has some
limitations, so I've decided to reimplement it in Jifty and improve.

=head1 Introduction

Here is simple example:

    my $articles = new MyApp::ArticleCollection;
    $articles->tisql->query(
        ".author.name = 'ruz'"
        ." AND .status = 'published'"
        ." AND .tags.value = 'tisql'"
    );

Nice, isn't it? Yep, we think so too.

=head1 Basic syntax

=head2 Boolean logic

Everything is pretty simple here:

=over 4

=item boolean operator - 'AND' and 'OR'

=item paranthesis - '(' and ')'

=item boolean operands - our conditions

=back

So the following is our simple boolean expression:

    ( <a condition> OR <condition> ) AND <condition>

In query language itself we'll have operators and operands too, we'll try
to avoid cofusion by clarifing if it's boolean's or TISQL's. I'll use paren
for paranthesis and open/close paren (/) respectively.

See also L<Parse::BooleanLogic> for details on internals.

=head2 Quoting

As usually happens with strings we need some quoting. Almost all literal
strings have to be quoted with " or ' and only quoting character inside
have to be escaped with '\'. Some examples:

    "a string"
    "ruz's cool string"
    'ruz\'s cool string'
    'we can have "mixed" quoting'

=head1 Conditions

=head2 Basic syntax

Some examples:

    .resolved IS NULL
    .id = 1
    .created > '2008-03-25'
    .subject like 'Re: %'

So each condition is an operator, a column on its left side and constant or
another column on the right. Operators like IS NULL has nothing on right side.

=head2 Simple operators

=over 4

=item =, != - equality

=item IS NULL, IS NOT NULL - tests for NULLs

=item <, >, <=, >= - ranges

=item LIKE, NOT LIKE - string pattern matching

=back

So everything is simple as in SQL.

=head2 Column syntax

Grammar:

    [<alias>] ( '.' <column> )*

Alias is optional and most of the time you don't need them, however them
are desperatedly required in some situations, read about that below XXX
link goes here. Let's leave them alone for now.

When you apply a tisql query you do it on a collection of records, for
example C<MyApp::Model::UserCollection>. Records in this collection have
columns described by schema of the model C<MyApp::Model::User>. You skip
alias to say that you want column of records in base collection, each
column is prefixed with literal dot character, for example:

    .real_name
    .organization

JDBI supports referes_to definition for columns to declare named references
to other records and collections. In tisql you can use this advantage and
continue columns sequence to build conditions based on properties of
related objects, for example:

    .member_of.name
    # where member_of refers to groups collection, each group has name
    # column

    .owner_of.tags.value
    # where owner_of referes to tasks collection and tasks have tags

Summary: an optional alias followed by one or more dot column pairs.

=head2 Conditions on related records

What do you expect to find when you write the following query:

    .tags.value != 'X'

Most people want to find all records without tag 'X', records without
tags or records that has no tag 'X'. We're not exceptional to this desire.
So not equal and negative pattern matching operators on long column sequences
behave as 'find records which have no related objects with properties equal
or matching the value/pattern'.

More examples:

    .member_of.name != 'sales department'
    .depends_on.status != 'done'

Note that 'IS NOT NULL' operator is not affected. This can be changed as
it's not clear what is better.

=head2 Extended conditions on related records.

As we figured out earlier each record in the collection you're limiting can
be related to multiple sets of records. In such situation conditions
described above are too limitted. Tisql provide 'has' and 'has no'
conditions modifiers.

=over 4

=item C<has .reference.property = 'x'> - the same as C<.column.property =
'x'>.

=item C<has no .reference.property = 'x'> - the same as C<.column.property
!= 'x'>.

=item C<has .reference.property != 'x'> - find records which refers to at
least one record with property != 'x', for example C<has
.sub_projects.status != 'done'> which find projects that have at least one
not finished sub project.

=item C<has no .reference.property != 'x'> - find records which has no
refererences to records with property != 'x', for example C<has no
.sub_projects.status != 'done'> which finds projects that either have no
sub projects or all sub projects are done.

=item C<has .reference> - the same as C<.reference.id IS NOT NULL>

=item C<has no .reference> - the same as C<.reference.id IS NULL>

=back

These prefixes work for other conditions as well.

=head2 Aliasing

Let's start from an example:

    .members.first_name = 'John' AND .member.last_name = 'Doe'

What will it find? Groups where John Doe is member or some John and some
Doe are members of the same Group? Without an alias the latter will happen.
To achive the former results you have to use the following query:

    FROM .members AS member
    WHERE member.first_name = 'John'
        AND member.last_name = 'Doe'

RFC: better syntax is required

What is alias? As we start column spcifications from one collection then
whole query looks like a star. Using an alias we can merge rays pointing to
the same related objects and check different properties of these objects.

May be not that clear description :-), but this works as described above.

Condition prefixes ('has' and 'has no') don't work for first level aliased
columns, for example 'has no member.first_name != "John"' is illegal, but
'member.first_name = "John" AND has member.member_of.name = "Sales" is ok.
The last search finds all groups with some John as memeber, however this
John should be from Sales group.

Considering above "alias.column != 'x'" and other negative conditions
behave as ".column != 'x'", so "member.first_name != 'John'" will find a
groups where some members exist and none of them is John.

Is it limitation? Yes and no. It's helpful in situation as above, but has
no other big advantages I can think of. As well plenty of situations can be
effectivly solved by extended references and placeholders. I'm open to
suggestions about either transforming aliases into something more useful or
replacing them with another nice syntax.

=head2 Where are joins?

Tisql has no joins in that fashion we used to see them in SQL. You have
refers_to columns and that's your joins. Each column that refers to another
collection or record is a way to join record(s) to another one and define
conditions of such relation.

=head3 Extended refers_to column declarations

By default JDBI allow you to use only one column in references using
"by 'column'" when tisql upgrades this to a new level. Example:

    package TestApp::User;
    ...
    use Jifty::DBI::Record schema {
        column login => type is 'varchar(36)';
        column attrs =>
            refers_to TestApp::AttributeCollection
                by tisql => "attrs.model = 'User' AND attrs.record = .id";
    };

In the query used for references you have additional alias by default, name
of the alias and name of the column are equal.

These columns generate accessors as well, so you can call C<< $user->attrs
>> that will return TestApp::AttributeCollection.

=head3 Adding new columns at run-time

You can add virtual columns to models at run-time, right before applying a
query, for example:

    $users_obj->tisql
        # reference to collection of (group id, member id) pairs
        ->add_reference(
            name      => 'gm',
            refers_to => 'TestApp::UserToGroupCollection',
            tisql     => 'gm.person = .id',
        # reference to groups a user is member of using previous reference
        )->add_reference(
            name      => 'member_of',
            refers_to => 'TestApp::GroupCollection',
            tisql     => '.gm.grp = member_of.id',
        )->query('.member_of.name = "Sales"');

These columns may be used very often and most probably want to add them
persistently to the User model, but this is just an example.

=head3 Placeholders

Adding new columns for different combinations of joins conditions all the
time is not an option. As well aliases have some limitations as you may
want adjust join conditions.

Placeholders is the way to help withthis - join conditions with arguments,
for example:

    column groups =>
        references MyApp::Model::GroupCollection
        by tisql => 'groups.instance = .id'
            .' AND groups.domain = "role"'
            .' AND groups.type = %type';

Values for placeholders can be defined using the following syntax:

    .groups{type => 'some'}.

If placeholder is not defined then condition is properly avoided.

Placeholders can be used in other references too, and renamed if
you like:

    column actor =>
        references MyApp::Model::UserCollection
        by tisql => '.groups{type => %role}.member.id = actor.id';

=head3 Using code to choose different join conditions

An reference to a code can be used as join:

    column X =>
        references MyApp::Model::Y
        by tisql => sub { ... },

Subroutine is called when join is required and should return
hash with join query.

=cut

